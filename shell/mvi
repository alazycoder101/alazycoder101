#!/usr/bin/env bash
#
# This script merges audio with images or videos in various ways using ffmpeg.
#

set -euo pipefail
IFS=$'\n\t'

shopt -s extglob

# The round function (original from stempell.com, lightly adjusted).
round() {
  local number precision
  number="$1"
  precision="$2"
  # Use printf for final output. The bc expression is kept close to your original logic.
  printf "%.${precision}f\n" "$(echo "scale=${precision};(((10^${precision})*${number})+0.5)/(10^${precision})" | bc)"
}

usage() {
  cat <<EOF
Usage: mvi [options...]
  -a <audio>    Audio file
  -i <image>    Image file
  -c <color>    Font color
  -s <size>     Font size
  -b <color>    Background color
  -l            Landscape (blurred sidebars) mode
  -d <duration> Duration
  -n <number>   Number
  -t <text>     Text overlay
  -r <resize>   Resize (fps or dimension)
  -q <qrfile>   QR file for overlay
  -o            "only" mode (disable text overlay)
  -h <height>   Desired height

Examples:
  mvi -a audio.mp3                  # Change metadata
  mvi -a audio.mp3 -n 2             # Break into 2 files
  mvi -i img.jpg                    # Scroll single image to video
  mvi -i img%02d.jpg                # Merge multiple images to video
  mvi -a audio%.mp3                 # Concatenate audio files
  mvi -a video%.mp4                 # Concatenate video files
  mvi -a video%.mp4 -h 360          # Resize multiple videos
  mvi -a audio.mp3 -i image.jpg     # Merge single audio+image
  mvi -i merge.csv -a audio.mp3     # Image slides with text, from CSV

Input file formats:
  concat.txt            concat.csv                    concatv.txt
  file '001.jpg'        timestamp,file,text           file '1.mp4'
  duration 10           00:00:00,1.jpg,title          outpoint 00:01:00
                        ...
Notes:
  To merge video files, ensure same FPS first:
    ffmpeg -i input.mp4 -filter:v fps=30 -max_muxing_queue_size 1024 out.mp4

EOF
  exit 1
}

# Show usage if no arguments.
if [[ $# -lt 1 ]]; then
  usage
fi

# Parse options.
audio=""
image=""
color=""
fontsize=""
bgcolor=""
rate=""
height=""
text=""
number=""
duration=""
QR=""
only=""
landscape=""

while getopts "q:t:n:r:a:d:i:c:s:b:h:ol" option; do
  case "${option}" in
    a) audio="${OPTARG}"   ;;
    i) image="${OPTARG}"   ;;
    c) color="${OPTARG}"   ;;
    s) fontsize="${OPTARG}";;
    b) bgcolor="${OPTARG}" ;;
    r) rate="${OPTARG}"    ;;
    h) height="${OPTARG}"  ;;
    t) text="${OPTARG}"    ;;
    n) number="${OPTARG}"  ;;
    d) duration="${OPTARG}";;
    q) QR="${OPTARG}"      ;;
    o) only="true"         ;;
    l) landscape="true"    ;;
    *) usage ;;
  esac
done

FONT_FILE="/Library/Fonts/Arial Unicode.ttf"

# Figure out a base title
if [[ -z "$audio" ]]; then
  file="$(basename "$image")"
else
  file="$(basename "$audio")"
fi
title="${file%.*}"

#-----------------------------------------------------------------
# If -h <height> was given, just do a quick resize of the input video
#-----------------------------------------------------------------
if [[ -n "$height" && -n "$audio" ]]; then
  ffmpeg -i "$audio" -vf "scale=-2:${height}" "resize_${title}.mp4"
  exit 0
fi

#-----------------------------------------------------------------
# Handling "audio only" (no -i)
#-----------------------------------------------------------------
if [[ -z "$image" ]]; then
  # 1) If audio has '%' -> we are concatenating multiple audio/video
  if [[ "$audio" == *"%"* ]]; then
    # We remove the literal '%' in the variable to expand them.
    # For example: "audio%02d.mp3" becomes "audio01.mp3 audio02.mp3 ...".
    audio="${audio//%/\*}"
    mapfile -t files < <(compgen -G "$audio")
    echo "Found ${#files[@]} files to concatenate."
    if [[ ${#files[@]} -eq 0 ]]; then
      echo "No files match pattern! Exiting."
      exit 1
    fi
    f="${files[1]}"
    ext="${f##*.}"
    ffmpeg -safe 0 -f concat -i <(
      for f in "${files[@]}"; do
        echo "file '$PWD/$f'"
      done
    ) -c copy "merged.${ext}"
    exit 0
  fi

  # 2) If -t <text> is supplied, we overlay text on existing video
  if [[ -n "$text" ]]; then
    # No dimension scale was computed so set scale to something minimal or remove it:
    scale=""  
    if [[ -n "$fontsize" && -n "$color" ]]; then
      ffmpeg -v error -i "$audio" \
        -vf "drawtext=text='${text}':fontfile='${FONT_FILE}':fontsize=${fontsize}:fontcolor=${color}@1:x=(w-text_w)/2:y=h-th-1:box=1:boxcolor=black@0.8:boxborderw=0${scale:+,$scale}" \
        "${title}-text.mp4"
    else
      # default color=white font=14 if not provided
      ffmpeg -v error -i "$audio" \
        -vf "drawtext=text='${text}':fontfile='${FONT_FILE}':fontsize=14:fontcolor=white@1:x=(w-text_w)/2:y=h-th-1:box=1:boxcolor=black@0.8:boxborderw=0${scale:+,$scale}" \
        "${title}-text.mp4"
    fi
    exit 0
  fi

  # 3) If -n <number> -> split into segments. Otherwise just update metadata
  if [[ -z "$number" ]]; then
    DESC="$(date +%s)"
    # Setting metadata
    ffmpeg -i "$audio" \
      -metadata title="$title" \
      -metadata description="$DESC" \
      -c copy "${DESC}-${audio}"
  else
    # Split file
    full_duration="$(ffprobe -i "$audio" -show_entries format=duration -v quiet -of csv="p=0")"
    # Floor the float to integer
    full_duration="${full_duration%.*}"

    # Avoid divide-by-zero if user passes -n 0
    if [[ "$number" -eq 0 ]]; then
      echo "Error: -n cannot be 0."
      exit 1
    fi

    segment_duration=$(( (full_duration + number - 1)/number + 1 ))
    ext="${audio##*.}"
    ffmpeg -i "$audio" \
      -f segment \
      -segment_time "$segment_duration" \
      -codec copy \
      -reset_timestamps 1 \
      -segment_start_number 1 \
      "${title}-%02d.${ext}"
  fi
  exit 0
fi

#-----------------------------------------------------------------
# If we have an image
#-----------------------------------------------------------------

# Get dimensions (width, height) from image.
# We replace `eval $(...)` with direct read while using "grep" or "awk" approach.
# This approach extracts the width/height lines and stores them in shell variables.
width="$(ffprobe -v error -select_streams v:0 -show_entries stream=width \
  -of default=noprint_wrappers=1:nokey=1 "$image")"
height_img="$(ffprobe -v error -select_streams v:0 -show_entries stream=height \
  -of default=noprint_wrappers=1:nokey=1 "$image")"

# We can compute ratio. If ratio>2, do your vertical-speed logic
ratio="$(round "$(bc -l <<<"${height_img}/${width}")" 0)"

if (( ratio > 2 )); then
  speed=2
  frames="$(round "$(bc -l <<<"${height_img}/${speed}")" 0)"
  wheight="$(round "$(bc -l <<<"9*${width}/16")" 0)"
  echo "Detected tall ratio. We'll create a scrolling effect. Final height: ${wheight}"
  wwidth="${width}"
  ffmpeg \
    -f lavfi -i "color=s=${wwidth}x${wheight}" \
    -i "$image" \
    -filter_complex "[0][1]overlay=x=0:y=H-${speed}*n" \
    -vframes "$frames" \
    "${title}.mp4"
  exit 0
fi

# Default rate if not provided
rate="${rate:-1/5}"

# If duration not provided, we read it from the audio
if [[ -z "$duration" ]]; then
  duration="$(ffprobe -i "$audio" -show_entries format=duration -v quiet -of csv="p=0")"
fi

bitrate="$(ffprobe -i "$audio" -show_entries format=bit_rate -v quiet -of csv="p=0")"
bitrate="${bitrate:-128000}"  # fallback if empty

#-----------------------------------------------------------------
# Handling text input or CSV
#-----------------------------------------------------------------
if [[ "$image" == *".txt" ]]; then
  width=640
  height=480
  scale="scale=w=${width}:h=${height}:force_original_aspect_ratio=1,pad=${width}:${height}:(ow-iw)/2:(oh-ih)/2"
  AOPTION=""
  [[ -n "$audio" ]] && AOPTION="-i \"$audio\""

  ffmpeg -v error -f concat -safe 0 -i "$image" \
    ${AOPTION} \
    -c:v libx264 -c:a aac -pix_fmt yuv420p \
    -vf "$scale" -r "$rate" -crf 23 -t "$duration" -shortest -y "${title}.mp4"

  exit 0
elif [[ "$image" == *".csv" ]]; then
  #
  # Slideshow from CSV:
  #   timestamp,file,text
  # We collect them, build segments, possibly handle GIF, then combine.
  #
  prev=""
  i=0
  has_gif=0

  : > f.srt
  : > f.txt
  : > f.sh

  while IFS=, read -r ts csvfile csvtext; do
    # Skip header if i=0 (assuming the first line is header)
    if [[ $i -eq 0 ]]; then
      ((i=i+1))
      continue
    fi

    if [[ -z "$prev" ]]; then
      prev="$ts"
      prev_file="$csvfile"
      prev_text="$csvtext"
      echo "file $csvfile" >> f.txt
    else
      # Writing SRT
      echo "$((i-1))" >> f.srt
      echo "${prev},000 --> ${ts},000" >> f.srt
      echo "$prev_text" >> f.srt
      echo >> f.srt

      # Convert HH:MM:SS to seconds
      # Mac version (original):
      start="$(date -j -f "%H:%M:%S" "$prev" +%s)"
      end="$(date -j -f "%H:%M:%S" "$ts" +%s)"
      # For Linux, replace with:
      # start="$(date -u -d "1970-01-01 $prev UTC" +%s)"
      # end="$(date -u -d "1970-01-01 $ts UTC" +%s)"

      dur="$(( end - start ))"
      echo "duration $dur" >> f.txt

      printf -v num "%03d" "$i"
      if [[ "$prev_file" == *.gif ]]; then
        has_gif=1
        # Get GIF framerate
        gif_rate="$(ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate \
          -of default=noprint_wrappers=1:nokey=1 "$prev_file")"
        echo "GIF found with rate=$gif_rate"
        echo "ffmpeg -ignore_loop 0 -i \"$prev_file\" -movflags faststart -pix_fmt yuv420p -vf \"scale=trunc(iw/2)*2:trunc(ih/2)*2\" -t $dur \"t${num}.mp4\"" >> f.sh
      else
        echo "ffmpeg -v error -loop 1 -i \"$prev_file\" -c:v libx264 -tune stillimage -pix_fmt yuv420p -vf \"scale=trunc(iw/2)*2:trunc(ih/2)*2\" -t $dur \"t_${num}.mp4\"" >> f.sh
      fi

      # Next segment starts at 'file'
      if [[ -n "$csvfile" ]]; then
        echo "file $csvfile" >> f.txt
      fi
      prev="$ts"
      prev_file="$csvfile"
      prev_text="$csvtext"
    fi
    ((i=i+1))
  done < "$image"

  width=640
  height=480
  scale="scale=w=${width}:h=${height}:force_original_aspect_ratio=1,pad=${width}:${height}:(ow-iw)/2:(oh-ih)/2"

  AOPTION=""
  if [[ -n "$audio" ]]; then
    AOPTION="-i \"$audio\""
  fi

  if [[ "$has_gif" -eq 0 ]]; then
    # No GIF, just do direct concat
    if [[ -z "$audio" ]]; then
      ffmpeg -v error -f concat -safe 0 -i "f.txt" \
        -c:v libx264 -c:a aac -pix_fmt yuv420p \
        -vf "$scale" -r "$rate" -t "$duration" -shortest -y "${title}.mp4"
    else
      ffmpeg -v error -f concat -safe 0 -i "f.txt" \
        -i "$audio" \
        -c:v libx264 -c:a aac -pix_fmt yuv420p \
        -vf "$scale" -r "$rate" -t "$duration" -shortest -y "${title}.mp4"
    fi
    ffmpeg -v error -i "${title}.mp4" -vf "subtitles=f.srt" -max_muxing_queue_size 1024 "s-${title}.mp4"
  else
    # We must first generate t_*.mp4 from GIF frames, then concat
    echo "ffmpeg -safe 0 -f concat -i <(for f in t_*.mp4; do echo \"file '$PWD/\$f'\"; done) $AOPTION -c:v libx264 -c:a aac -pix_fmt yuv420p -vf '$scale' -r $rate -t $duration -shortest -y ${title}.mp4" >> f.sh
    echo "ffmpeg -v error -i \"${title}.mp4\" -vf \"subtitles=f.srt\" -max_muxing_queue_size 1024 \"s-${title}.mp4\"" >> f.sh
    echo "Check f.sh for commands to run for GIF segments."
  fi
  exit 0
fi

#-----------------------------------------------------------------
# Final fallback: merging a single image + audio into a video
#-----------------------------------------------------------------

# For a single image, we confirm the "pad=..." logic so it’s even:
scale="pad=width=ceil(iw/2)*2:height=ceil(ih/2)*2"

# If the user gave a pattern like image%02d.jpg, do a standard scale for all frames.
if [[ "$image" == *"%"* ]]; then
  # Adjust width/height logic. For brevity, we’ll keep it simpler:
  width="${width:-1280}"
  height_img="${height_img:-720}"
  # Force aspect ratio
  scale="scale=w=${width}:h=${height_img}:force_original_aspect_ratio=1,pad=${width}:${height_img}:(ow-iw)/2:(oh-ih)/2"
fi

# If input is a GIF
image_option="-r $rate -f image2 -loop 1"
if [[ "$image" == *.gif ]]; then
  # detect real framerate from the GIF
  gif_rate="$(ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate \
    -of default=noprint_wrappers=1:nokey=1 "$image")"
  image_option="-r $gif_rate -ignore_loop 0"
fi

# Generate text overlay
safe_text="${title//%/\\\\%}"

# If user used -o ("only"), skip the text overlay
if [[ -n "$only" ]]; then
  ffmpeg $image_option -i "$image" \
    -i "$audio" \
    -c:v libx264 -tune stillimage \
    -c:a aac -b:a "$bitrate" \
    -pix_fmt yuv420p \
    -vf "${scale}" \
    -t "$duration" \
    -shortest \
    "${title}.mp4"
else
  # Decide how large the text can be.
  chars="$(echo -n "$title" | wc -m | grep -oE "[0-9]+")"
  MIN_FONT_SIZE=14
  GAP=20
  if [[ -z "$fontsize" ]]; then
    fontsize="$(round "(${width}-${GAP})/${chars}" 0)"
  fi
  fontsize="${fontsize:-14}"

  echo "Image width=${width} height=${height_img}, computed font size=${fontsize}"
  color="${color:-white}"
  bgcolor="${bgcolor:-black}"

  # If we have "landscape" blur
  land=""
  if [[ -n "$landscape" ]]; then
    # blurred sidebars
    #   [0:v] -> split -> [original][copy]
    #   [copy] -> scale=ih*16/9:-1 -> gblur -> [blurred]
    #   overlay [blurred][original]
    # Make sure you keep your comma inside the filter chain
    land=",split[original][copy];[copy]scale=ih*16/9:-1,crop=h=iw*9/16,gblur=sigma=20[blurred];[blurred][original]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2"
  fi

  # If the calculated fontsize is big enough:
  if (( fontsize >= MIN_FONT_SIZE )); then
    ffmpeg -v error $image_option -i "$image" \
      -i "$audio" \
      -c:v libx264 -tune stillimage \
      -c:a aac -b:a "$bitrate" \
      -pix_fmt yuv420p \
      -t "$duration" \
      -shortest \
      -vf "drawtext=text='${safe_text}':fontfile='${FONT_FILE}':fontsize=${fontsize}:fontcolor=${color}@1:x=(w-text_w)/2:y=h-th-1:box=1:boxcolor=black@0.8:boxborderw=0,${scale}${land}" \
      "${title}.mp4"
  else
    # If text does not fit nicely, we do a "marquee" style scrolling horizontally
    # or something similar
    ffmpeg -v error $image_option -i "$image" \
      -i "$audio" \
      -c:v libx264 -tune stillimage \
      -c:a aac -b:a "$bitrate" \
      -pix_fmt yuv420p \
      -t "$duration" \
      -shortest \
      -vf "${scale},drawtext=text='${safe_text}':fontfile='${FONT_FILE}':fontsize=40:fontcolor=white@1:x=w-mod(50*t\,(w+text_w)):y=h-th-1:box=1:boxcolor=black@0.8" \
      "${title}.mp4"
  fi
fi

# If we have a QR code file, overlay it.
if [[ -n "$QR" ]]; then
  ffmpeg -i "${title}.mp4" -i "$QR" \
    -filter_complex "[1:v][0:v]scale2ref=oh:ih/5[v1][bk1];[bk1][v1]overlay=W-w-5:5" \
    -max_muxing_queue_size 1024 \
    "QR-${title}.mp4"
fi
