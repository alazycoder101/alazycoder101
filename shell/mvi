#!/usr/bin/env bash
# Improved multimedia processing script with error handling and portability

set -o errexit
set -o nounset
set -o pipefail

shopt -s extglob nullglob

# Configuration
: "${FONT_FILE:=}"
DEFAULT_FONTS=(
    "/Library/Fonts/Arial Unicode.ttf" 
    "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
)
for font in "${DEFAULT_FONTS[@]}"; do
    if [[ -f "$font" ]]; then
        FONT_FILE="$font"
        break
    fi
done

# Functions
die() {
    echo "Error: $*" >&2
    exit 1
}

validate_dependencies() {
    local deps=("ffmpeg" "ffprobe" "convert")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null; then
            die "Required command not found: $dep"
        fi
    done
}

round() {
    local number="$1" decimals="$2"
    LC_ALL=C printf "%.${decimals}f" "$number" | awk '{printf "%.'$decimals'f\n", $1}'
}

validate_input_file() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        die "Input file not found: $file"
    fi
}

resize_video() {
    local input="$1" height="$2" title="$3"
    ffmpeg -hide_banner -loglevel error -i "$input" \
        -vf "scale=-2:${height}" \
        -c:v libx264 -preset fast \
        "resize_${title}.mp4"
}

merge_audio_files() {
    local pattern="$1" ext
    pattern="${pattern//%/*}"
    local files=($pattern)
    ext="${files[0]##*.}"
    
    ffmpeg -hide_banner -loglevel error -safe 0 -f concat \
        -i <(printf "file '%s'\n" "${files[@]}") \
        -c copy "merged.${ext}"
}

add_text_to_video() {
    local input="$1" text="$2" font="$3" fontsize="$4" color="$5" output
    output="${input%.*}-text.mp4"
    
    ffmpeg -hide_banner -loglevel error -i "$input" \
        -vf "drawtext=text='${text//\'/\\\'}':fontfile='${font//\'/\\\'}':fontsize=${fontsize}:fontcolor=${color}@1:x=(w-text_w)/2:y=h-th-1:box=1:boxcolor=black@0.8:boxborderw=0" \
        -c:a copy "$output"
}

usage() {
    cat <<EOF
Usage: ${0##*/} [options] 
Multimedia processing script for merging audio/images, creating videos, etc.

Options:
  -a FILE    Audio file
  -i FILE    Image file
  -c COLOR   Font color (default: white)
  -s SIZE    Font size
  -b COLOR   Background color
  -l         Landscape mode
  -d SECONDS Duration
  -n NUM     Split into NUM files
  -t TEXT    Overlay text
  -r RATE    Frame rate (default: 1/5)
  -h HEIGHT  Resize video to HEIGHT
  -q FILE    Add QR code overlay
  -o         Only basic processing
  --help     Show this help

Examples:
  ${0##*/} -a audio.mp3 -i image.jpg    Create video from image+audio
  ${0##*/} -a video.mp4 -h 360         Resize video to 360p
EOF
    exit
}

main() {
    validate_dependencies

    # Variable initialization
    local audio image color fontsize bgcolor rate height text number duration QR only landscape
    local width height title scale land AOPTION

    # Parse options
    while getopts ":a:i:c:s:b:r:h:t:n:d:q:ol" opt; do
        case $opt in
            a) audio=$OPTARG ;;
            i) image=$OPTARG ;;
            c) color=$OPTARG ;;
            s) fontsize=$OPTARG ;;
            b) bgcolor=$OPTARG ;;
            r) rate=$OPTARG ;;
            h) height=$OPTARG ;;
            t) text=$OPTARG ;;
            n) number=$OPTARG ;;
            d) duration=$OPTARG ;;
            q) QR=$OPTARG ;;
            o) only=true ;;
            l) landscape=true ;;
            *) usage ;;
        esac
    done

    # Input validation
    [[ -z "$audio" && -z "$image" ]] && die "Either audio or image must be specified"
    [[ -n "$audio" ]] && validate_input_file "$audio"
    [[ -n "$image" ]] && validate_input_file "$image"

    # File naming
    if [[ -n "$audio" ]]; then
        title=$(basename "${audio%.*}")
    else
        title=$(basename "${image%.*}")
    fi

    # Processing modes
    if [[ -n "$height" ]]; then
        validate_input_file "$audio"
        resize_video "$audio" "$height" "$title"
        exit
    fi

    if [[ -n "$audio" && "$audio" == *"%"* ]]; then
        merge_audio_files "$audio"
        exit
    fi

    # Remaining processing logic (text overlay, CSV handling, etc.) 
    # should be similarly refactored into functions with proper validation

    # ... (rest of the logic using the same patterns)
}

main "$@"